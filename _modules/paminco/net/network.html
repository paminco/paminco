
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>paminco.net.network &#8212; paminco 0.1 documentation</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/contentui.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/paminco.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/user_guide.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/api.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/contentui.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../../../index.html">
<p class="title">paminco</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../getting_started.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../user_guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api/index.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../theory/index.html">
  Theoretical Background
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/paminco/paminco" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for paminco.net.network</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">et</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sps</span>

<span class="kn">from</span> <span class="nn">.cost</span> <span class="kn">import</span> <span class="n">NetworkCost</span><span class="p">,</span> <span class="n">PolynomialCost</span><span class="p">,</span> <span class="n">SymbolicCost</span><span class="p">,</span> <span class="n">PiecewiseQuadraticCost</span>
<span class="kn">from</span> <span class="nn">.demand</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DemandFunction</span><span class="p">,</span>
    <span class="n">LinearDemandFunction</span><span class="p">,</span>
    <span class="n">AffineDemandFunction</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.path</span> <span class="kn">import</span> <span class="n">csr_dijkstra</span><span class="p">,</span> <span class="n">csr_dijkstra_mp</span><span class="p">,</span> <span class="n">get_path_edges</span>
<span class="kn">from</span> <span class="nn">.shared</span> <span class="kn">import</span> <span class="n">Shared</span><span class="p">,</span> <span class="n">Edges</span><span class="p">,</span> <span class="n">Nodes</span><span class="p">,</span> <span class="n">FlowDirection</span>
<span class="kn">from</span> <span class="nn">._convert_traffic</span> <span class="kn">import</span> <span class="n">read_tntp</span>
<span class="kn">from</span> <span class="nn">._convert_gas</span> <span class="kn">import</span> <span class="n">gaslib_to_network_data</span>
<span class="kn">from</span> <span class="nn">paminco.utils.io</span> <span class="kn">import</span> <span class="n">prettify_xml</span>
<span class="kn">from</span> <span class="nn">paminco.linalg</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">SingularLaplaceError</span><span class="p">,</span>
    <span class="n">star_inv</span><span class="p">,</span>
    <span class="n">star_update_by_edge</span><span class="p">,</span>
    <span class="n">InverseMethod</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">paminco.utils.misc</span> <span class="kn">import</span> <span class="n">Cache</span>
<span class="kn">from</span> <span class="nn">paminco.utils.typing</span> <span class="kn">import</span> <span class="n">is_iterable</span><span class="p">,</span> <span class="n">sparse_format</span>
<span class="kn">from</span> <span class="nn">paminco</span> <span class="kn">import</span> <span class="n">_doc</span>
<span class="kn">import</span> <span class="nn">paminco.net.demand</span> <span class="k">as</span> <span class="nn">netdemand</span>


<span class="k">class</span> <span class="nc">Support</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A class representing the support (of a flow).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ecost : ndarray</span>
<span class="sd">        The edge cost of the flow.</span>
<span class="sd">    p_diff : ndarray</span>
<span class="sd">        The potential differences of the flow.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    rtol : float, default=1e-5</span>
<span class="sd">        The relative tolerance when comparing ecost - p_diff to zero.</span>
<span class="sd">    atol : float, default=1e-8</span>
<span class="sd">        The absolute tolerance when comparing ecost - p_diff to zero.</span>
<span class="sd">    active</span>
<span class="sd">    inactive</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.isclose</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ecost</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">p_diff</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
            <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slack</span> <span class="o">=</span> <span class="n">ecost</span> <span class="o">-</span> <span class="n">p_diff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return True if edge is an active edge of this edge.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compare this support to other support or array of edges.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Support</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Support cannot be compared to object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the number of active edges.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a string representation of this support.&quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;&lt;Support&gt; Active Edges: &quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_active</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slack</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">active</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;ndarray of int: indices of the active edges.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slack</span><span class="p">))[</span><span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">()]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inactive</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;ndarray of int: indices of the inactive edges.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slack</span><span class="p">))[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">())]</span>


<div class="viewcode-block" id="Network"><a class="viewcode-back" href="../../../api/net/network.html#paminco.net.Network">[docs]</a><span class="k">class</span> <span class="nc">Network</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A Network.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    edge_data : edge_data</span>
<span class="sd">        Data that specifies edges. See also</span>
<span class="sd">        :class:`paminco.net.shared.Edges`.</span>
<span class="sd">    node_data : node_data, optional</span>
<span class="sd">        Data that specifies nodes. If None, nodes will be inferred from</span>
<span class="sd">        ``edge_data``. See also  :class:`paminco.net.shared.Nodes`</span>
<span class="sd">    cost_data : cost_data, optional</span>
<span class="sd">        Edge costs. If None, linear cost functions ``F_e(x_e) = x_e``</span>
<span class="sd">        are assumed for all edges.</span>
<span class="sd">    demand_data : demand_data, optional</span>
<span class="sd">        Commodity data to initialize a DemandFunction. See also</span>
<span class="sd">        :meth:`Network.set_demand() &lt;Network.set_demand&gt;`.</span>
<span class="sd">    dtype_float : dtype, default=float</span>
<span class="sd">        Datatype for float data arrays.</span>
<span class="sd">    dtype_int : dtype, default=int</span>
<span class="sd">        Datatype for integer data arrays.</span>
<span class="sd">    update_shared : bool, default=True</span>
<span class="sd">        Whether to update shared data after initialization.</span>
<span class="sd">    directed_flow : bool, default=True</span>
<span class="sd">        Controls default values for ``None`` in edge bounds. If ``True``,</span>
<span class="sd">        lower bounds are set to 0 and ``False`` to -inf. Missing upper</span>
<span class="sd">        bounds are set to inf.</span>
<span class="sd">    demand_mode : str, default=&quot;linear&quot;</span>
<span class="sd">        How to interpret ``demand_data``, see also</span>
<span class="sd">        :meth:`Network.set_demand() &lt;Network.set_demand&gt;`.</span>
<span class="sd">    kw_edge : keyword arguments, optional</span>
<span class="sd">        Further keyword arguments passed to Edge constructor.</span>
<span class="sd">    kw_demand : keyword arguments, optional</span>
<span class="sd">        Further keyword arguments passed to</span>
<span class="sd">        :meth:`Network.set_demand() &lt;Network.set_demand&gt;`.</span>
<span class="sd">    kw_cost : keyword arguments, optional</span>
<span class="sd">        Further keyword arguments passed to</span>
<span class="sd">        :meth:`Network.set_cost() &lt;Network.set_cost&gt;`.</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    paminco.net.shared.Shared : Nodes, edge initialization.</span>
<span class="sd">    Network.set_demand : Demand initialization.</span>
<span class="sd">    Network.set_cost : Cost initialization.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: def _check_consistency...</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">edge_data</span><span class="p">,</span>
            <span class="n">node_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">cost_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">demand_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dtype_float</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">dtype_int</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="n">update_shared</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">directed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">demand_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">clean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">kw_edge</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">kw_demand</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">kw_cost</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kw_edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw_edge</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">directed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;directed&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw_edge</span><span class="p">:</span>
            <span class="n">kw_edge</span><span class="p">[</span><span class="s2">&quot;directed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">directed</span>
            
        <span class="k">if</span> <span class="n">kw_demand</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw_demand</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">demand_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw_demand</span><span class="p">:</span>
            <span class="n">kw_demand</span><span class="p">[</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">demand_mode</span>
        
        <span class="k">if</span> <span class="n">kw_cost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw_cost</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># init shared object (edges, nodes)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="n">Shared</span><span class="p">(</span><span class="n">edge_data</span><span class="p">,</span>
                         <span class="n">node_data</span><span class="p">,</span>
                         <span class="n">dtype_float</span><span class="o">=</span><span class="n">dtype_float</span><span class="p">,</span>
                         <span class="n">dtype_int</span><span class="o">=</span><span class="n">dtype_int</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kw_edge</span><span class="p">)</span>
        
        <span class="c1"># Init demand if given</span>
        <span class="k">if</span> <span class="n">demand_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_demand</span><span class="p">(</span><span class="n">demand_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_demand</span><span class="p">)</span>
            
        <span class="c1"># Init costs: if not given, linear cost functions with slope of</span>
        <span class="c1"># one are assumed</span>
        <span class="k">if</span> <span class="n">cost_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cost_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cost</span><span class="p">(</span><span class="n">cost_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_cost</span><span class="p">)</span>
        
        <span class="c1"># Init cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
        
        <span class="c1"># Clean network</span>
        <span class="k">if</span> <span class="n">clean</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">clean</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;zones&quot;</span><span class="p">,</span>
                <span class="s2">&quot;parallel_edges&quot;</span><span class="p">,</span>
                <span class="s2">&quot;zero_cost_edges&quot;</span><span class="p">,</span>
                <span class="s2">&quot;isolated_nodes&quot;</span><span class="p">,</span>
                <span class="s2">&quot;unreachable_nodes&quot;</span><span class="p">,</span>
                <span class="s2">&quot;commodities&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clean</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">clean</span> <span class="o">=</span> <span class="p">[</span><span class="n">clean</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_iterable</span><span class="p">(</span><span class="n">clean</span><span class="p">):</span>
            <span class="n">clean_kw</span> <span class="o">=</span> <span class="p">{(</span><span class="s2">&quot;remove_&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">):</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">clean</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clean</span><span class="p">(</span><span class="o">**</span><span class="n">clean_kw</span><span class="p">)</span>
        
        <span class="c1"># Update shared network object for id &lt;-&gt; lbl mappings</span>
        <span class="k">if</span> <span class="n">update_shared</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_shared</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Network</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;_s&quot;</span><span class="p">,</span> <span class="s2">&quot;_c&quot;</span><span class="p">,</span> <span class="s2">&quot;_d&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">att</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">att</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;Network with </span><span class="si">{:d}</span><span class="s2"> nodes and </span><span class="si">{:d}</span><span class="s2"> edges.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hard</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">hard</span><span class="o">=</span><span class="n">hard</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Demand function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>

<div class="viewcode-block" id="Network.set_demand"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.set_demand.html#paminco.net.Network.set_demand">[docs]</a>    <span class="k">def</span> <span class="nf">set_demand</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">is_label</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">map_label</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set demand of network.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : demand-like, optional</span>
<span class="sd">            If ``data`` is a</span>
<span class="sd">            :class:`~paminco.net.demand.DemandFunction`,</span>
<span class="sd">            demand is set to ``data``. Else, demand will be set based</span>
<span class="sd">            on ``mode``.</span>
<span class="sd">        is_label : bool, default=True</span>
<span class="sd">            Whether commodities in ``data`` have labels.</span>
<span class="sd">        map_label : bool, default=True</span>
<span class="sd">            Whether to map node labels in ``data`` to node ids.</span>
<span class="sd">        mode : str, default=&#39;linear&#39;</span>
<span class="sd">            1.&#39;linear&#39;:</span>
<span class="sd">              ``data`` is used to build</span>
<span class="sd">              :class:`~paminco.net.demand.LinearDemandFunction`.</span>
<span class="sd">            2.&#39;affine&#39;:</span>
<span class="sd">              ``data`` is used to build</span>
<span class="sd">              :class:`~paminco.net.demand.AffineDemandFunction`.</span>
<span class="sd">            3.&#39;to_linear&#39;:</span>
<span class="sd">               Use current demand direction to build</span>
<span class="sd">               :class:`~paminco.net.demand.LinearDemandFunction`,</span>
<span class="sd">               ``data`` must be None.</span>
<span class="sd">            4.&#39;to_affine&#39;:</span>
<span class="sd">               Build</span>
<span class="sd">               :class:`~paminco.net.demand.AffineDemandFunction`</span>
<span class="sd">               where base demand is set by ``data``. Demand direction</span>
<span class="sd">               is used from current demand function.</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Arguments passed to LinearDemandFunction or</span>
<span class="sd">            :class:`~paminco.net.demand.AffineDemandFunction`.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``mode == &#39;affine&#39;`` and ``data`` is not a tuple of</span>
<span class="sd">            len = 2.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``mode == &#39;to_linear&#39;`` and ``data`` is not None.</span>
<span class="sd">        TypeError</span>
<span class="sd">            If ``mode == &#39;to_affine&#39;`` and demand of network is not a</span>
<span class="sd">            :class:`~paminco.net.demand.LinearDemandFunction`.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``mode`` is not in [&#39;linear&#39;, &#39;affine&#39;, &#39;to_linear&#39;,</span>
<span class="sd">            &#39;to_affine].</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Setting a linear demand function that consists of two</span>
<span class="sd">        commodities. A commodity may be specified by a tuple (source,</span>
<span class="sd">        target, rate) or a dict {source: -rate, target1: rate/2,</span>
<span class="sd">        target2: rate/2}.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; net = paminco.net.load_sioux()</span>
<span class="sd">        &gt;&gt;&gt; net.set_demand([(1, 2, 400), {7: -100, 4: 100}], is_label=False)</span>
<span class="sd">        &gt;&gt;&gt; net.demand(1.5).toarray()[:8]</span>
<span class="sd">        array([[   0.,    0.],</span>
<span class="sd">               [-600.,    0.],</span>
<span class="sd">               [ 600.,    0.],</span>
<span class="sd">               [   0.,    0.],</span>
<span class="sd">               [   0.,  150.],</span>
<span class="sd">               [   0.,    0.],</span>
<span class="sd">               [   0.,    0.],</span>
<span class="sd">               [   0., -150.]])</span>
<span class="sd">               </span>
<span class="sd">        Setting an affine demand function.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; net = paminco.net.load_sioux()</span>
<span class="sd">        &gt;&gt;&gt; net.set_demand(((1, 2, 400), (7, 4, 100)), is_label=False, mode=&quot;affine&quot;)</span>
<span class="sd">        &gt;&gt;&gt; net.demand(3).toarray()[:8]</span>
<span class="sd">        array([[   0.],</span>
<span class="sd">               [-400.],</span>
<span class="sd">               [ 400.],</span>
<span class="sd">               [   0.],</span>
<span class="sd">               [ 300.],</span>
<span class="sd">               [   0.],</span>
<span class="sd">               [   0.],</span>
<span class="sd">               [-300.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DemandFunction</span><span class="p">):</span>
            <span class="c1"># Data is demand func</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Data will be read from xml</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">DemandFunction</span><span class="o">.</span><span class="n">from_xml</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                              <span class="n">shared</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="p">,</span>
                                              <span class="n">is_label</span><span class="o">=</span><span class="n">is_label</span><span class="p">,</span>
                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">LinearDemandFunction</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                           <span class="n">shared</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="p">,</span>
                                           <span class="n">is_label</span><span class="o">=</span><span class="n">is_label</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;affine&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mode==&#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39; requires tuple of data.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">AffineDemandFunction</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">,</span>
                                           <span class="n">shared</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="p">,</span>
                                           <span class="n">is_label</span><span class="o">=</span><span class="n">is_label</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;to_linear&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mode==&#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39; accepts no data.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">LinearDemandFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                                           <span class="n">shared</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="p">,</span>
                                           <span class="n">is_label</span><span class="o">=</span><span class="n">is_label</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;to_affine&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="p">,</span> <span class="n">LinearDemandFunction</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;mode==&#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39; requires demand to be of type &quot;</span>
                    <span class="s2">&quot;LinearDemandFunction.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">AffineDemandFunction</span><span class="p">(</span><span class="n">b0</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                           <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                                           <span class="n">shared</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="p">,</span>
                                           <span class="n">is_label</span><span class="o">=</span><span class="n">is_label</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mode==&#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39; not valid.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">map_label</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_label</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">.</span><span class="n">map_node_id_to_label</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">.</span><span class="n">map_node_label_to_id</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<div class="viewcode-block" id="Network.set_cost"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.set_cost.html#paminco.net.Network.set_cost">[docs]</a>    <span class="k">def</span> <span class="nf">set_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_cost</span><span class="p">,</span> <span class="n">cost_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set edge costs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_cost : edge_cost</span>
<span class="sd">            Cost of edges.</span>
<span class="sd">        cost_type : str, optional</span>
<span class="sd">            Type of cost data.</span>
<span class="sd">            TODO-PW</span>
<span class="sd">        kw : keyword arguments</span>
<span class="sd">            Further keyword arguments passed to cost constructor.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.cost.NetworkCost.from_data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_cost</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_cost</span><span class="p">,</span> <span class="n">et</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_cost</span><span class="p">,</span> <span class="n">et</span><span class="o">.</span><span class="n">Element</span><span class="p">)):</span>
            <span class="c1"># Read from XML</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">NetworkCost</span><span class="o">.</span><span class="n">from_xml</span><span class="p">(</span><span class="n">edge_cost</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_cost</span><span class="p">,</span> <span class="n">NetworkCost</span><span class="p">):</span>
            <span class="c1"># Is already network cost</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">edge_cost</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cost_type</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_cost</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)):</span>
                <span class="n">cost_type</span> <span class="o">=</span> <span class="s2">&quot;symbolic&quot;</span>
            
            <span class="k">if</span> <span class="n">cost_type</span> <span class="o">==</span> <span class="s2">&quot;symbolic&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">SymbolicCost</span><span class="p">(</span><span class="n">edge_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shared</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="p">,</span> <span class="o">**</span><span class="n">edge_cost</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cost_type</span> <span class="o">==</span> <span class="s2">&quot;piecewisequadratic&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">PiecewiseQuadraticCost</span><span class="p">(</span><span class="n">edge_cost</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If data is given, assume polynomial cost</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">PolynomialCost</span><span class="p">(</span><span class="n">edge_cost</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.integrate_cost"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.integrate_cost.html#paminco.net.Network.integrate_cost">[docs]</a>    <span class="k">def</span> <span class="nf">integrate_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Integrate edge costs.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.cost.PolynomialCost.integrate</span>
<span class="sd">        paminco.net.cost.PiecewiseQuadraticCost.integrate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.derivate_cost"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.derivate_cost.html#paminco.net.Network.derivate_cost">[docs]</a>    <span class="k">def</span> <span class="nf">derivate_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Derivate edge costs.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.cost.PolynomialCost.derivate</span>
<span class="sd">        paminco.net.cost.PiecewiseQuadraticCost.derivate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">PolynomialCost</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">derivate</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.adjacency_matrix"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.adjacency_matrix.html#paminco.net.Network.adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Alias for :func:`~Network.csgraph`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">csgraph</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Network.csgraph"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.csgraph.html#paminco.net.Network.csgraph">[docs]</a>    <span class="k">def</span> <span class="nf">csgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">csgraph</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span></div>
    
    <span class="n">csgraph</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Shared</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="Network.incidence_matrix"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.incidence_matrix.html#paminco.net.Network.incidence_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">incidence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Alias for :func:`~Network.Gamma`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gamma</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Network.Gamma"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.Gamma.html#paminco.net.Network.Gamma">[docs]</a>    <span class="k">def</span> <span class="nf">Gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">Gamma</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    <span class="n">Gamma</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Shared</span><span class="o">.</span><span class="n">Gamma</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="Network.gamma_times"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.gamma_times.html#paminco.net.Network.gamma_times">[docs]</a>    <span class="k">def</span> <span class="nf">gamma_times</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">return_as</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;csr&#39;</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate Gamma @ x.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Argument.</span>
<span class="sd">        node : int, optional</span>
<span class="sd">            If given, result of dot product from row slice</span>
<span class="sd">            Gamma[node, :] and x is returned::</span>
<span class="sd">            </span>
<span class="sd">                Gamma[node, :] @ x</span>
<span class="sd">                </span>
<span class="sd">        return_as : str, default=&quot;csr&quot;</span>
<span class="sd">            Return type of dot product if result is spmatrix.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or spmatrix</span>
<span class="sd">            Dot product of Gamma and x.</span>
<span class="sd">            </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.dot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gamma</span><span class="p">(</span><span class="n">return_as</span><span class="o">=</span><span class="n">return_as</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">G</span> <span class="o">@</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">sps</span><span class="o">.</span><span class="n">isspmatrix</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sparse_format</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">return_as</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Network.times_gamma"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.times_gamma.html#paminco.net.Network.times_gamma">[docs]</a>    <span class="k">def</span> <span class="nf">times_gamma</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="n">edge</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">return_as</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;csr&#39;</span>
            <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate x @ Gamma.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray or spmatrix</span>
<span class="sd">            Argument.</span>
<span class="sd">        edge : int, optional</span>
<span class="sd">            If given, result of dot product of x and column slice is</span>
<span class="sd">            returned::</span>
<span class="sd">            </span>
<span class="sd">                x @ Gamma[:, edge]</span>
<span class="sd">            </span>
<span class="sd">        return_as : str, default=&quot;csr&quot;</span>
<span class="sd">            Return type of dot product if result is spmatrix.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or spmatrix</span>
<span class="sd">            Dot product of x and Gamma.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.dot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Standard computation via dot product</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">x</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gamma</span><span class="p">(</span><span class="n">return_as</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use sparsity of Gamma</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">s</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">sps</span><span class="o">.</span><span class="n">isspmatrix</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sparse_format</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">return_as</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Network.laplacian"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.laplacian.html#paminco.net.Network.laplacian">[docs]</a>    <span class="k">def</span> <span class="nf">laplacian</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">reduced</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">return_as</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;csr&#39;</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the (weighted) Laplacian matrix L.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight : float or np.ndarray, optional</span>
<span class="sd">            If None, unit weight is assumed for all edges. If float,</span>
<span class="sd">            all edges have the same weight.</span>
<span class="sd">        reduced : bool, default=False</span>
<span class="sd">            Whether to return the reduced form, i.e., without first row</span>
<span class="sd">            and first column.</span>
<span class="sd">        return_as : str, default=&#39;csr&#39;</span>
<span class="sd">            Return format for sparse matrix.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        L : spmatrix</span>
<span class="sd">            Laplacian matrix of shape (n, n) if ``reduced`` is False,</span>
<span class="sd">            else of shape (n-1, n-1). Type of return matrix is</span>
<span class="sd">            determined by parameter ``return_as``.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Laplacian_matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cast weight to array of len(m) if not np.ndarray</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_float</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">weight</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid argument for weight: </span><span class="si">{</span><span class="n">weight</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="s2">&quot;lap&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># Rebuild if not valid in cache</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">T</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
            <span class="n">coo</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;lap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coo</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Pull from cache</span>
            <span class="n">coo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;lap&quot;</span><span class="p">]</span>
            <span class="n">coo</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">w</span>
            
        <span class="k">if</span> <span class="n">reduced</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sparse_format</span><span class="p">(</span><span class="n">coo</span><span class="p">,</span> <span class="n">return_as</span><span class="p">)[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">sparse_format</span><span class="p">(</span><span class="n">coo</span><span class="p">,</span> <span class="n">return_as</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Network.L"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.L.html#paminco.net.Network.L">[docs]</a>    <span class="k">def</span> <span class="nf">L</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">flow</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">reduced</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">return_as</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;csr&#39;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get weighted Laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight : np.ndarray, optional</span>
<span class="sd">            If None, weigths are determined based on flow.</span>
<span class="sd">            The Laplace weight of an edge e for a flow x_e is defined</span>
<span class="sd">            as ``1 / c&#39;&#39;(x_e)``, where c&#39;&#39; is the second derivative of</span>
<span class="sd">            the edge costs.</span>
<span class="sd">        flow : np.ndarray, optional</span>
<span class="sd">            Use flow to determine weights if ``weights is None``.</span>
<span class="sd">        reduced : bool, default=False</span>
<span class="sd">            Whether to return the reduced form, i.e., without first row</span>
<span class="sd">            and first column.</span>
<span class="sd">        return_as : str, default=&#39;csr&#39;</span>
<span class="sd">            Return format for sparse matrix.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spmatrix</span>
<span class="sd">            Laplacian matrix of shape (n, n) if ``reduced`` is False,</span>
<span class="sd">            else of shape (n-1, n-1). Type of return matrix is</span>
<span class="sd">            determined by parameter ``return_as``.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Network.laplacian</span>
<span class="sd">        paminco.net.cost.NetworkCost.laplace_weights</span>
<span class="sd">        paminco.net.cost.PiecewiseQuadraticCost.laplace_weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">laplace_weights</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">laplacian</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">return_as</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.Lstar"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.Lstar.html#paminco.net.Network.Lstar">[docs]</a>    <span class="k">def</span> <span class="nf">Lstar</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">flow</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">reduced</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">method</span><span class="p">:</span> <span class="n">InverseMethod</span> <span class="o">=</span> <span class="n">InverseMethod</span><span class="o">.</span><span class="n">CHOLESKY</span><span class="p">,</span>
            <span class="n">safe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pseudo-inverse of weighted Laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight : np.ndarray, optional</span>
<span class="sd">            If None, weigths of Laplacian are determined based on flow.</span>
<span class="sd">        flow : np.ndarray, optional</span>
<span class="sd">            Use flow to determine weights if ``weights is None``.</span>
<span class="sd">        reduced : bool, default=False</span>
<span class="sd">            Whether to return the reduced form, i.e., without first row</span>
<span class="sd">            and first column.</span>
<span class="sd">        method: int, str, or InverseMethod, default=InverseMethod.CHOLESKY</span>
<span class="sd">            Method used to calculate inverse.</span>
<span class="sd">        safe : bool, default=True</span>
<span class="sd">            If True (default), matrix will only be inverted if network is</span>
<span class="sd">            connected.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or CholeskyInverse</span>
<span class="sd">            The pseudo inverse of the weighted Laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        SingularLaplaceError</span>
<span class="sd">            Network is not connected.</span>
<span class="sd">        numpy.linalg.LinAlgError</span>
<span class="sd">            Inverting matrix failed.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Network.connected_components : Connectedness of the network.</span>
<span class="sd">        Network.L : Laplacian matrix.</span>
<span class="sd">        paminco.linalg.star_inv : generalized inverse of a matrix.</span>
<span class="sd">        paminco.linalg.CholeskyInverse : Inverting a matrix using choleksy decomposition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">InverseMethod</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        
        <span class="c1"># Safemode checks connectedness of graph beforehand in order to</span>
        <span class="c1"># detect singular laplace matrix</span>
        <span class="k">if</span> <span class="n">safe</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">laplace_weights</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">n_cc</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">weight</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n_cc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SingularLaplaceError</span><span class="p">(</span><span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                           <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                                           <span class="n">n_cc</span><span class="o">=</span><span class="n">n_cc</span><span class="p">,</span>
                                           <span class="n">cc</span><span class="o">=</span><span class="n">cc</span><span class="p">)</span>
        
        <span class="n">lap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="n">reduced</span><span class="p">,</span> <span class="n">return_as</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">raise_laplace_error</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lstar</span> <span class="o">=</span> <span class="n">star_inv</span><span class="p">(</span><span class="n">lap</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="n">reduced</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">lae</span><span class="p">:</span>
            <span class="c1"># Laplace inverse can not be obtained</span>
            <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Recover the weights used, if not specified</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">laplace_weights</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">weight</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># If the error is due to multiple connected components</span>
                <span class="c1"># of active edges, raise SingularLaplaceError</span>
                <span class="n">raise_laplace_error</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Unknown source of LinAlgError -&gt; Raise the normal error</span>
                <span class="k">raise</span> <span class="n">lae</span>
            
        <span class="k">if</span> <span class="n">raise_laplace_error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SingularLaplaceError</span><span class="p">(</span><span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">lstar</span></div>

<div class="viewcode-block" id="Network.Lstar_update"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.Lstar_update.html#paminco.net.Network.Lstar_update">[docs]</a>    <span class="k">def</span> <span class="nf">Lstar_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update pseudo-inverse of weighted Laplacian.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Network.Lstar</span>
<span class="sd">        paminco.linalg.star_update_by_edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">updated_matrix</span> <span class="o">=</span> <span class="n">star_update_by_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SingularLaplaceError</span><span class="p">(</span><span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">updated_matrix</span></div>

<div class="viewcode-block" id="Network.shortest_path"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.shortest_path.html#paminco.net.Network.shortest_path">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">backward_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">backward_positive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">multiprocessing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">return_source_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute shortest path wrt. weight.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight : array_like, optional</span>
<span class="sd">            Edge weights, default: unit weight (1) for all edges.</span>
<span class="sd">        s : int or array_like, optional</span>
<span class="sd">            If specified, only compute the paths originating at the</span>
<span class="sd">            given indices. Default: all nodes in edges.</span>
<span class="sd">        backward_edges : bool, default=False</span>
<span class="sd">            Whether to use separate entries in adjacency matrix H for</span>
<span class="sd">            undirected edges, i.e., H[s, t] = w and H[t, s] = w.</span>
<span class="sd">        backward_positive : bool, default=False</span>
<span class="sd">            Whether to negate weight for undirected edges, i.e.,</span>
<span class="sd">            H[s, t] = w and H[t, s] = -w.</span>
<span class="sd">        multiprocessing : bool, default=False</span>
<span class="sd">            Whether to calculate D and Pr using multiple processes.</span>
<span class="sd">        return_source_indices : bool, default=False</span>
<span class="sd">            Whether to return dict that maps node_id in ``s`` to indices</span>
<span class="sd">            in return matrices D and Pr.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        D : ndarray</span>
<span class="sd">            Distance matrix.</span>
<span class="sd">        Pr: ndarray</span>
<span class="sd">            Predecessor matrix.</span>
<span class="sd">        dict, optional</span>
<span class="sd">            Mapping of node_id in ``s`` to indices in D and Pr if</span>
<span class="sd">            ``return_source_indices`` is True.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.shared.Shared.csgraph :</span>
<span class="sd">            Setup of adjacency matrix used to find shortest path.</span>
<span class="sd">        scipy.sparse.csgraph.dijkstra : Shortest path computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set weight to ones if not given</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
        
        <span class="c1"># get adjacency matrix form edge class</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">csgraph</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span>
                                  <span class="n">respect_bounds</span><span class="o">=</span><span class="n">backward_edges</span><span class="p">,</span>
                                  <span class="n">backward_positive</span><span class="o">=</span><span class="n">backward_positive</span><span class="p">)</span>
        
        <span class="c1"># set sources to all nodes in network if not given</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
        <span class="k">if</span> <span class="n">adj</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;win&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">multiprocessing</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">D</span><span class="p">,</span> <span class="n">Pr</span> <span class="o">=</span> <span class="n">csr_dijkstra_mp</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">D</span><span class="p">,</span> <span class="n">Pr</span> <span class="o">=</span> <span class="n">csr_dijkstra</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">D</span><span class="p">,</span> <span class="n">Pr</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span>
                                                  <span class="n">indices</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                                                  <span class="n">return_predecessors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">sps</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">NegativeCycleError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_last_adj_matrix</span> <span class="o">=</span> <span class="n">adj</span>
                <span class="k">raise</span> <span class="n">ex</span>
        
        <span class="k">if</span> <span class="n">return_source_indices</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">Pr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">Pr</span></div>

<div class="viewcode-block" id="Network.flow_on_shortest"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.flow_on_shortest.html#paminco.net.Network.flow_on_shortest">[docs]</a>    <span class="k">def</span> <span class="nf">flow_on_shortest</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">demand_triples</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">unique_sources</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">multiprocessing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">commodity_wise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find flow on shortest path.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight : ndarray, optional</span>
<span class="sd">            Weight to compute predecessor matrix.</span>
<span class="sd">        demand_triples : list of tuple</span>
<span class="sd">            Find flow on shortest path for all commoditiies specified by</span>
<span class="sd">            ``(source, target, demand)``.</span>
<span class="sd">        unique_sources : ndarray, optional</span>
<span class="sd">            If specified, only compute the paths from the nodes at the</span>
<span class="sd">            given indices.</span>
<span class="sd">        multiprocessing : bool, default=False</span>
<span class="sd">            Whether to use multiprocessing to compute the shortest path</span>
<span class="sd">            matrices D and Pr.</span>
<span class="sd">        commodity_wise : bool, default=False</span>
<span class="sd">            Whether to return to return flow on shortest path for each</span>
<span class="sd">            commodity individually, i.e., a matrix F of shape (m, c) is</span>
<span class="sd">            returned where F[:, i] is the flow for commodity at index</span>
<span class="sd">            i. Warning: is considerably slower for a large c.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or lil_matrix</span>
<span class="sd">            Aggregated or commodity wise flow.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">Pr</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span>
                                      <span class="n">s</span><span class="o">=</span><span class="n">unique_sources</span><span class="p">,</span>
                                      <span class="n">multiprocessing</span><span class="o">=</span><span class="n">multiprocessing</span><span class="p">,</span>
                                      <span class="n">return_source_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Pr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Pr</span> <span class="o">=</span> <span class="n">Pr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        
        <span class="c1"># For all commodities: update flow on shortest path between pairs</span>
        <span class="c1"># (s -&gt; t with rate r)</span>
        <span class="k">if</span> <span class="n">commodity_wise</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Individual flow for each commodity</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">demand_triples</span><span class="p">)))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">demand_triples</span><span class="p">):</span>
                <span class="n">path_edges</span> <span class="o">=</span> <span class="n">get_path_edges</span><span class="p">(</span><span class="n">Pr</span><span class="o">=</span><span class="n">Pr</span><span class="p">,</span>
                                            <span class="n">s</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">],</span>
                                            <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                                            <span class="n">lookup_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">nodes2edge</span><span class="p">,</span>
                                            <span class="nb">reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">flow</span><span class="p">[</span><span class="n">path_edges</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Aggregated edge flow across commodities</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">demand_triples</span><span class="p">:</span>
                <span class="n">path_edges</span> <span class="o">=</span> <span class="n">get_path_edges</span><span class="p">(</span><span class="n">Pr</span><span class="o">=</span><span class="n">Pr</span><span class="p">,</span>
                                            <span class="n">s</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">],</span>
                                            <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                                            <span class="n">lookup_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">nodes2edge</span><span class="p">,</span>
                                            <span class="nb">reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">flow</span><span class="p">[</span><span class="n">path_edges</span><span class="p">]</span> <span class="o">+=</span> <span class="n">r</span>
        
        <span class="k">return</span> <span class="n">flow</span></div>

<div class="viewcode-block" id="Network.connected_components"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.connected_components.html#paminco.net.Network.connected_components">[docs]</a>    <span class="k">def</span> <span class="nf">connected_components</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">return_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract connected components from network.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges : int or array_like, optional</span>
<span class="sd">            If not None, get connected components for sub-network build</span>
<span class="sd">            from ``edges``.</span>
<span class="sd">        return_labels : bool, default=True</span>
<span class="sd">            If True (default), return the labels for each of the</span>
<span class="sd">            connected components.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_components: int</span>
<span class="sd">            The number of connected components.</span>
<span class="sd">        labels: ndarray, optional</span>
<span class="sd">            The length-N array of labels of the connected components.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.sparse.csgraph.connected_components</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">            &gt;&gt;&gt; import paminco</span>
<span class="sd">            &gt;&gt;&gt; net = paminco.net.load_sioux()</span>
<span class="sd">            &gt;&gt;&gt; net.delete_nodes([&quot;6&quot;, &quot;9&quot;, &quot;11&quot;, &quot;13&quot;], is_label=True)</span>
<span class="sd">            &gt;&gt;&gt; net.connected_components(return_labels=False)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="s2">&quot;csgraph_unitweight&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Rebuild adj</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">T</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
                <span class="n">adj</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;csgraph_unitweight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Pull unit weighted adj from cache</span>
                <span class="n">adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;csgraph_unitweight&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">edges</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">adj</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">sps</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span>
                                                <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="n">return_labels</span><span class="o">=</span><span class="n">return_labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.is_connected"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.is_connected.html#paminco.net.Network.is_connected">[docs]</a>    <span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check whether edges are connected.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges : int or array_like, optional</span>
<span class="sd">            Indices of network edges to check connectedness for.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether edges are connected.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Network.connected_components</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">            &gt;&gt;&gt; import paminco</span>
<span class="sd">            &gt;&gt;&gt; net = paminco.net.load_sioux()</span>
<span class="sd">            &gt;&gt;&gt; net.delete_nodes([&quot;6&quot;, &quot;9&quot;, &quot;11&quot;, &quot;13&quot;], is_label=True)</span>
<span class="sd">            &gt;&gt;&gt; net.is_connected()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">num_cc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.support_of"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.support_of.html#paminco.net.Network.support_of">[docs]</a>    <span class="k">def</span> <span class="nf">support_of</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">flow</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Support</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the support of the flow.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flow : numpy.ndarray</span>
<span class="sd">            Flow to find support for</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Support</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">ddx</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
        <span class="n">cost</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">lb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Compute potential</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="n">cost</span><span class="p">,</span>
                                  <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                  <span class="n">backward_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">gamma_pi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times_gamma</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Support</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">gamma_pi</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.potential"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.potential.html#paminco.net.Network.potential">[docs]</a>    <span class="k">def</span> <span class="nf">potential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">fixed_vertex</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate potential of a flow.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flow : ndarray</span>
<span class="sd">            Flow on network edges.</span>
<span class="sd">        fixed_vertex : int, default=0</span>
<span class="sd">            Specifies which node/vertex used as reference.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pot : ndarray</span>
<span class="sd">            Potential of flow.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Network.shortest_path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">ddx</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
        <span class="n">pot</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="n">cost</span><span class="p">,</span>
                                    <span class="n">s</span><span class="o">=</span><span class="n">fixed_vertex</span><span class="p">,</span>
                                    <span class="n">backward_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pot</span></div>

    <span class="k">def</span> <span class="nf">_fullfills_flow_cond</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">flow</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">param</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">return_actual_target</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">):</span>
        <span class="c1"># TODO-PW umbennen, etc</span>
        <span class="c1"># Check whether total in/outflow in nodes corresponds to demand vector:</span>
        <span class="c1"># Gamma * flow = b</span>
        <span class="n">actual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_times</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">return_actual_target</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">valid</span><span class="p">,</span> <span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">valid</span>

<div class="viewcode-block" id="Network.clean"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.clean.html#paminco.net.Network.clean">[docs]</a>    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">remove_zones</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">remove_parallel_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">remove_zero_cost_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">remove_isolated_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">remove_unreachable_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">remove_commodities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">start_node_unreachables</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Clean network.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remove_zones : bool, default=False</span>
<span class="sd">            Whether to remove all nodes in network.nodes that are</span>
<span class="sd">            flagged as a zone node.</span>
<span class="sd">        remove_parallel_edges : bool, default=True</span>
<span class="sd">            Whether to remove parallel edges. E.g., if two edges exist</span>
<span class="sd">            that have the same source and the same target, only the</span>
<span class="sd">            first edge is kept.</span>
<span class="sd">        remove_zero_cost_edges : bool, default=True</span>
<span class="sd">            Whether to remove edges that have zero costs.</span>
<span class="sd">        remove_isolated_nodes : bool, default=False</span>
<span class="sd">            Whether to remove nodes that are isolated, i.e., nodes in</span>
<span class="sd">            the network that do not have any edges associated with</span>
<span class="sd">            them.</span>
<span class="sd">        remove_unreachable_nodes : bool, default=False</span>
<span class="sd">            Whether to remove nodes that are unreachable from</span>
<span class="sd">            ``start_node_unreachables``. If this is not given,</span>
<span class="sd">            unreachable nodes from the first node in network.nodes are</span>
<span class="sd">            removed.</span>
<span class="sd">        remove_commodities : bool, default=False</span>
<span class="sd">            Whether to remove commodities made up by nodes which are</span>
<span class="sd">            deleted in the cleaning process.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Summary of cleaning process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get network size before cleaning (nodes, edges, commodities)</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">remove_zones</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_zones</span><span class="p">(</span><span class="n">remove_commodities</span><span class="o">=</span><span class="n">remove_commodities</span><span class="p">,</span>
                                      <span class="n">update_shared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remove_parallel_edges</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_parallel_edges</span><span class="p">(</span><span class="n">update_shared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remove_zero_cost_edges</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_zero_cost_edges</span><span class="p">(</span><span class="n">update_shared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remove_isolated_nodes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># nodes that are in nodes but not in edges</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_isolated_nodes</span><span class="p">(</span><span class="n">remove_commodities</span><span class="o">=</span><span class="n">remove_commodities</span><span class="p">,</span>
                                               <span class="n">update_shared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remove_unreachable_nodes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># update indices if a previous method has manipulated network</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_unreachable_nodes</span><span class="p">(</span><span class="n">start_node</span><span class="o">=</span><span class="n">start_node_unreachables</span><span class="p">,</span>
                                                  <span class="n">remove_commodities</span><span class="o">=</span><span class="n">remove_commodities</span><span class="p">,</span>
                                                  <span class="n">update_shared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">remove_zones</span> <span class="ow">and</span> <span class="n">remove_zero_cost_edges</span> <span class="ow">and</span>
                <span class="n">remove_unreachable_nodes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;The combination of &quot;</span>
                <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">remove_zones==False&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">remove_zero_cost_edges==True&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">remove_unreachable_nodes==True&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">did result in 0 edges left in network&quot;</span>
            <span class="p">)</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Network does not have commodities!&quot;</span><span class="p">)</span>
        
        <span class="c1"># self.update_shared(map_demand_labels=remove_commodities)</span>
        
        <span class="n">out</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Nodes: </span><span class="si">{:d}</span><span class="s2"> -&gt; </span><span class="si">{:d}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Edges: </span><span class="si">{:d}</span><span class="s2"> -&gt; </span><span class="si">{:d}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Commodities: </span><span class="si">{:d}</span><span class="s2"> -&gt; </span><span class="si">{:d}</span><span class="s2">&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">out</span></div>

    <span class="k">def</span> <span class="nf">update_shared</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">map_demand_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update network elements by shared object.</span>
<span class="sd">        </span>
<span class="sd">        Keeps consistency across edges, nodes, demand and cost.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        map_demand_labels : bool, default=True</span>
<span class="sd">            Whether to remap labels to ids in network.demand</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">map_demand_labels</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_d&quot;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">map_node_label_to_id</span><span class="p">()</span>

<div class="viewcode-block" id="Network.delete_edges"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.delete_edges.html#paminco.net.Network.delete_edges">[docs]</a>    <span class="k">def</span> <span class="nf">delete_edges</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">edges</span><span class="p">,</span>
            <span class="n">update_shared</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Delete some edges from network.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges : int or array of ints</span>
<span class="sd">            Edges to delete from network.edges and network.cost</span>
<span class="sd">            objects.</span>
<span class="sd">        update_shared : bool, default=True</span>
<span class="sd">            Whether to updated shared network elements. Keeps</span>
<span class="sd">            consistency of network.edges to other network elements.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Amount of deleted edges.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.shared.Shared.delete_edges :</span>
<span class="sd">            Delete edges from Edges.</span>
<span class="sd">        paminco.net.cost.PolynomialCost.delete_edges :</span>
<span class="sd">            Delete edges from PolynomialCost.</span>
<span class="sd">        paminco.net.cost.PiecewiseQuadraticCost.delete_edges :</span>
<span class="sd">            Delete edges from PiecewiseQuadraticCost.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_cache</span><span class="p">()</span>
        
        <span class="c1"># Remove edges from edgelist</span>
        <span class="n">del_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Remove edges from cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span><span class="n">del_edges</span><span class="p">)</span>
        
        <span class="c1"># Update shared: mapping (nodeid, nodeid) -&gt; edgeid</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">del_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">update_shared</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">_set_edge_id_mapping</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">del_edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.delete_nodes"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.delete_nodes.html#paminco.net.Network.delete_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">delete_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">,</span>
            <span class="n">update_shared</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">is_label</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">remove_commodities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Delete some nodes from network.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : int, array of ints, str, or array of str</span>
<span class="sd">            Indices or labels of nodes to delete.</span>
<span class="sd">        update_shared : bool, default=True</span>
<span class="sd">            Whether to updated shared network elements. Keeps</span>
<span class="sd">            consistency to other network elements.</span>
<span class="sd">        is_label : bool, default=True</span>
<span class="sd">            Whether to delete by label or internal node index.</span>
<span class="sd">        remove_commodities : bool, default=True</span>
<span class="sd">            Whether to remove commodities made up by ``nodes``.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Amount of deleted nodes.</span>
<span class="sd">        int</span>
<span class="sd">            Amount of deleted commodities.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.shared.Shared.delete_nodes :</span>
<span class="sd">            Delete nodes from network.nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_cache</span><span class="p">()</span>
        
        <span class="c1"># Remove nodes from nodelist</span>
        <span class="n">del_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">delete_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span>
                                             <span class="n">is_label</span><span class="o">=</span><span class="n">is_label</span><span class="p">,</span>
                                             <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># Remove nodes from demand</span>
        <span class="n">n_del_coms</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">remove_commodities</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">n_del_coms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">delete_nodes</span><span class="p">(</span><span class="n">del_nodes</span><span class="p">)</span>
        
        <span class="c1"># Remove nodes from edges and costs</span>
        <span class="n">del_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">delete_nodes_in_edges</span><span class="p">(</span><span class="n">del_nodes</span><span class="p">,</span>
                                                      <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span><span class="n">del_edges</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">update_shared</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_shared</span><span class="p">(</span><span class="n">map_demand_labels</span><span class="o">=</span><span class="n">remove_commodities</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">del_nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">del_edges</span><span class="p">),</span> <span class="n">n_del_coms</span></div>

    <span class="k">def</span> <span class="nf">get_node_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_flow_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarry</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">get_flow_df</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_isolated_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">update_shared</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">remove_commodities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">nodes_in_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">all_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">isolated_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes_in_edges</span><span class="p">))</span>

        <span class="n">n_n</span><span class="p">,</span> <span class="n">n_m</span><span class="p">,</span> <span class="n">n_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isolated_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n_n</span><span class="p">,</span> <span class="n">n_m</span><span class="p">,</span> <span class="n">n_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delete_nodes</span><span class="p">(</span><span class="n">isolated_nodes</span><span class="p">,</span>
                                              <span class="n">is_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="n">update_shared</span><span class="o">=</span><span class="n">update_shared</span><span class="p">,</span>
                                              <span class="n">remove_commodities</span><span class="o">=</span><span class="n">remove_commodities</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;Removing isolated nodes:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> nodes</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_n</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> edges</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_m</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> commodities</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_remove_parallel_edges</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">update_shared</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">duplicate_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">get_duplicate_edges</span><span class="p">()</span>
        
        <span class="c1"># remove duplicates from data structs</span>
        <span class="n">n_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span><span class="n">duplicate_idx</span><span class="p">,</span> <span class="n">update_shared</span><span class="o">=</span><span class="n">update_shared</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;Removing parallel edges:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> edges</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_remove_unreachable_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">start_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">update_shared</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">remove_commodities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># Build adjaceny matrix with uniform weights = 1</span>
        <span class="n">adj_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">csgraph</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
                                         <span class="n">respect_bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">backward_positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># If no start_node is specified, use the first node from the</span>
        <span class="c1"># largest strongly connected component</span>
        <span class="k">if</span> <span class="n">start_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coco</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span>
            <span class="n">num_cc</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">coco</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">,</span>
                              <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">connection</span><span class="o">=</span><span class="s1">&#39;weak&#39;</span><span class="p">,</span>
                              <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">id_u</span><span class="p">,</span> <span class="n">cnt_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">id_u</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cnt_u</span><span class="p">)]</span>
            <span class="n">start_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">id_u</span> <span class="o">==</span> <span class="n">comp</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_node</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">start_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">get_node_id</span><span class="p">(</span><span class="n">start_node</span><span class="p">)</span>
        
        <span class="n">node_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">get_node_label</span><span class="p">(</span><span class="n">start_node</span><span class="p">)</span>
        
        <span class="c1"># Get all distances between nodes for weight = 1 and identity</span>
        <span class="c1"># unreachables where distance matrix is infinite</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">csr_dijkstra</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">start_node</span><span class="p">)</span>
        <span class="n">idx_unreachables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">D</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">n_n</span><span class="p">,</span> <span class="n">n_m</span><span class="p">,</span> <span class="n">n_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_unreachables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Delete nodes in nodes and reset mapping</span>
            <span class="n">n_n</span><span class="p">,</span> <span class="n">n_m</span><span class="p">,</span> <span class="n">n_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delete_nodes</span><span class="p">(</span><span class="n">idx_unreachables</span><span class="p">,</span>
                                              <span class="n">is_label</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">update_shared</span><span class="o">=</span><span class="n">update_shared</span><span class="p">,</span>
                                              <span class="n">remove_commodities</span><span class="o">=</span><span class="n">remove_commodities</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;Removing unreachable nodes from &#39;</span><span class="si">{:s}</span><span class="s2">&#39;:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> nodes</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_n</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> edges</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_m</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> commodities</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_remove_zero_cost_edges</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">update_shared</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="n">PolynomialCost</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;No zero cost edges removed. Cost are not polynomial.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">zc_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="o">.</span><span class="n">coefficients</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span><span class="n">zc_edges</span><span class="p">,</span> <span class="n">update_shared</span><span class="o">=</span><span class="n">update_shared</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;Removing zero cost edges:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> edges</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">zc_edges</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_remove_zones</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">update_shared</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">remove_commodities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;Cleaning zones:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">has_zones</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">No zone nodes in network.&quot;</span>
        <span class="c1"># Get zone nodes and delete</span>
        <span class="n">zone_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">zone</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">n_n</span><span class="p">,</span> <span class="n">n_m</span><span class="p">,</span> <span class="n">n_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delete_nodes</span><span class="p">(</span><span class="n">zone_nodes</span><span class="p">,</span>
                                          <span class="n">is_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">update_shared</span><span class="o">=</span><span class="n">update_shared</span><span class="p">,</span>
                                          <span class="n">remove_commodities</span><span class="o">=</span><span class="n">remove_commodities</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> nodes</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_n</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> edges</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_m</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{:d}</span><span class="s2"> commodities</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_flow_to_nx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">return_pos</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">to_df</span><span class="p">()[[</span><span class="s2">&quot;source_lbl&quot;</span><span class="p">,</span> <span class="s2">&quot;target_lbl&quot;</span><span class="p">]]</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;flow&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">return_pos</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No node coordinates set.&quot;</span><span class="p">)</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">xy</span>
            <span class="n">lbl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">labels</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lbl</span><span class="p">,</span> <span class="n">xy</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">pos</span>
        
        <span class="k">return</span> <span class="n">df</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_tntp_to_xml</span><span class="p">(</span>
            <span class="n">outfile</span><span class="p">,</span>
            <span class="n">netfile</span><span class="p">,</span>
            <span class="n">tripsfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">nodefile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">cost_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">prettify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">kw_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">kw_write</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">):</span>
        <span class="k">if</span> <span class="n">kw_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw_init</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">kw_write</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw_write</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Build network from tntp files</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">Network</span><span class="o">.</span><span class="n">from_tntp</span><span class="p">(</span>
            <span class="n">netfile</span><span class="p">,</span> <span class="n">tripsfile</span><span class="p">,</span> <span class="n">nodefile</span><span class="p">,</span> <span class="n">cost_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_init</span>
        <span class="p">)</span>
        
        <span class="c1"># Dump to xml</span>
        <span class="k">return</span> <span class="n">net</span><span class="o">.</span><span class="n">to_xml</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">prettify</span><span class="o">=</span><span class="n">prettify</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_write</span><span class="p">)</span>
    
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_tntp</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="n">netfile</span><span class="p">,</span>
            <span class="n">tripsfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">nodefile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">cost_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kw</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Network</span><span class="p">:</span>
        <span class="n">edge_data</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">cost_data</span><span class="p">,</span> <span class="n">demand_data</span> <span class="o">=</span> <span class="n">read_tntp</span><span class="p">(</span>
            <span class="n">netfile</span><span class="p">,</span> <span class="n">tripsfile</span><span class="p">,</span> <span class="n">nodefile</span><span class="p">,</span> <span class="n">cost_type</span>
        <span class="p">)</span>
        <span class="c1"># if cost_type != &quot;auto&quot;:</span>
        <span class="c1">#     if &quot;kw_cost&quot; not in kw:</span>
        <span class="c1">#         kw[&quot;kw_cost&quot;] = {}</span>
        <span class="c1">#     kw[&quot;kw_cost&quot;][&quot;cost_type&quot;] = cost_type</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">edge_data</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">cost_data</span><span class="p">,</span> <span class="n">demand_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_gaslib</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="n">network_file</span><span class="p">,</span>
            <span class="n">scenario_file</span><span class="p">,</span>
            <span class="n">contract_aux_elements</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">debug</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Network</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Read a gaslib instance from files and a network from the data.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        network_file : str</span>
<span class="sd">            The filename of the gaslib XML network file</span>
<span class="sd">        scenario_file : str</span>
<span class="sd">            The filename of the gaslib XML scenario file</span>
<span class="sd">            to be used as demands</span>
<span class="sd">        contract_aux_elements : boolean, default=True</span>
<span class="sd">            If set to True, auxiliary components (i.e. componentss that are not</span>
<span class="sd">            pipes, such as vales and compressors) are contracted. If set to False</span>
<span class="sd">            these components are modeled as pipes with very small resistances</span>
<span class="sd">        debug : boolean, default=False</span>
<span class="sd">            If set to True, some debug information are printed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        network : Network</span>
<span class="sd">            The network read from the files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">gaslib_to_network_data</span><span class="p">(</span>
            <span class="n">network_file</span><span class="p">,</span> <span class="n">scenario_file</span><span class="p">,</span> <span class="n">contract_aux_elements</span><span class="p">,</span> <span class="n">debug</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_gaslib_to_xml</span><span class="p">(</span>
            <span class="n">outfile</span><span class="p">,</span>
            <span class="n">network_file</span><span class="p">,</span>
            <span class="n">scenario_file</span><span class="p">,</span>
            <span class="n">contract_aux_elements</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">prettify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">kw_write</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a gaslib instance from files and a network from the data.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outfile : str</span>
<span class="sd">            The filename of the output xml file</span>
<span class="sd">        network_file : str</span>
<span class="sd">            The filename of the gaslib XML network file</span>
<span class="sd">        scenario_file : str</span>
<span class="sd">            The filename of the gaslib XML scenario file</span>
<span class="sd">            to be used as demands</span>
<span class="sd">        contract_aux_elements : boolean, default=True</span>
<span class="sd">            If set to True, auxiliary components (i.e. componentss that are not</span>
<span class="sd">            pipes, such as vales and compressors) are contracted. If set to False</span>
<span class="sd">            these components are modeled as pipes with very small resistances</span>
<span class="sd">        debug : boolean, default=False</span>
<span class="sd">            If set to True, some debug information are printed</span>
<span class="sd">        prettify : boolean, default=True</span>
<span class="sd">            If set to True, the xml code in the outputfile is written in a</span>
<span class="sd">            more readeable form</span>
<span class="sd">        kw_write : dict, default=None</span>
<span class="sd">            Additional keywords for Elementree.write</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        xml.etree.ElementTree.ElementTree.write</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">gaslib_to_network_data</span><span class="p">(</span>
            <span class="n">network_file</span><span class="p">,</span> <span class="n">scenario_file</span><span class="p">,</span> <span class="n">contract_aux_elements</span><span class="p">,</span> <span class="n">debug</span>
        <span class="p">)</span>
        <span class="n">network</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">network</span><span class="o">.</span><span class="n">to_xml</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">prettify</span><span class="o">=</span><span class="n">prettify</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_write</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_xml</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">file</span><span class="p">,</span>
            <span class="n">prettify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">write_kw</span>
            <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save Network as XML.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file : str or file object</span>
<span class="sd">            File name, or a file object opened for writing.</span>
<span class="sd">        prettify : bool, default=False</span>
<span class="sd">            Whether to prettify resulting XML file.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        xml.etree.ElementTree.ElementTree.write</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Init tree</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;network&#39;</span><span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        
        <span class="c1"># Add metadata subelement</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
        
        <span class="c1"># Fill tree with node, edges, cost, and demand</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_to_etree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span>
                                       <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">cost_writer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">add_to_etree</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">SymbolicCost</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="o">.</span><span class="n">costfuncs_to_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_to_etree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">add_to_etree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">**</span><span class="n">write_kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prettify</span><span class="p">:</span>
            <span class="n">prettify_xml</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

<div class="viewcode-block" id="Network.from_xml"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.from_xml.html#paminco.net.Network.from_xml">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_xml</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">return_dict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Network</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Read network from ``XML``.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : str, file, ElementTree or Element</span>
<span class="sd">            Initialize object from xml file by passing</span>
<span class="sd">                * filename as str,</span>
<span class="sd">                * file object that contains XML data,</span>
<span class="sd">                * the XML ElementTree,</span>
<span class="sd">                * or the root Element of the ElementTree.</span>
<span class="sd">        return_dict : bool, default=False,</span>
<span class="sd">            If ``True``, the data is returned as a dict with entries</span>
<span class="sd">            ``edge_data``, ``node_data``, ``demand_data`` and ``cost_data``.</span>
<span class="sd">            If ``False`` (default), a ``Network`` object created from</span>
<span class="sd">            this data is returned</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        net : Network or dict</span>
<span class="sd">            The network read from the data. If ``return_dict`` is True,</span>
<span class="sd">            a dict with the raw data is returned.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        xml.etree.ElementTree</span>
<span class="sd">        :func:`~paminco.net.shared.Edges.from_xml`</span>
<span class="sd">            ``from_xml`` method of Edges class</span>
<span class="sd">        :func:`~paminco.net.shared.Nodes.from_xml`</span>
<span class="sd">            ``from_xml`` method of Nodes class</span>
<span class="sd">        :func:`~paminco.net.cost.NetworkCost.from_xml`</span>
<span class="sd">            ``from_xml`` method of NetworkCost class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_data</span> <span class="o">=</span> <span class="n">Edges</span><span class="o">.</span><span class="n">from_xml</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">node_data</span> <span class="o">=</span> <span class="n">Nodes</span><span class="o">.</span><span class="n">from_xml</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">demand_data</span> <span class="o">=</span> <span class="n">file</span>
        <span class="c1"># Reading and initialization of Cost Function is</span>
        <span class="c1"># deferred to set_cost method</span>
        <span class="n">cost_data</span> <span class="o">=</span> <span class="n">file</span>

        <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;edge_data&#39;</span><span class="p">:</span> <span class="n">edge_data</span><span class="p">,</span>
                <span class="s1">&#39;node_data&#39;</span><span class="p">:</span> <span class="n">node_data</span><span class="p">,</span>
                <span class="s1">&#39;cost_data&#39;</span><span class="p">:</span> <span class="n">cost_data</span><span class="p">,</span>
                <span class="s1">&#39;demand_data&#39;</span><span class="p">:</span> <span class="n">demand_data</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">edge_data</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">cost_data</span><span class="p">,</span> <span class="n">demand_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">make_save_dict</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">save_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">save_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">save_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">make_save_dict</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
                                           <span class="n">save_dict</span><span class="o">=</span><span class="n">save_dict</span><span class="p">)</span>
        <span class="n">save_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">.</span><span class="n">make_save_dict</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;dem_&quot;</span><span class="p">,</span>
                                           <span class="n">save_dict</span><span class="o">=</span><span class="n">save_dict</span><span class="p">)</span>
        <span class="n">save_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="o">.</span><span class="n">make_save_dict</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;cost_&quot;</span><span class="p">,</span>
                                           <span class="n">save_dict</span><span class="o">=</span><span class="n">save_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">save_dict</span>
    
    <span class="n">make_save_dict</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_doc</span><span class="o">.</span><span class="n">make_save_dict</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">save_to_numpy</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">save_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_save_dict</span><span class="p">()</span>
        <span class="n">save_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">**</span><span class="n">save_dict</span><span class="p">)</span>
    
    <span class="n">save_to_numpy</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_doc</span><span class="o">.</span><span class="n">save_to_numpy</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="Network.from_npz"><a class="viewcode-back" href="../../../api/net/generated/paminco.net.Network.from_npz.html#paminco.net.Network.from_npz">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_npz</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Network</span><span class="p">:</span>
        <span class="n">net</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        
        <span class="c1"># load shared object (edges, nodes)</span>
        <span class="n">net</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="n">Shared</span><span class="o">.</span><span class="n">from_npz</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>
        
        <span class="c1"># load demand</span>
        <span class="n">class_</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">netdemand</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;demand_type&quot;</span><span class="p">]))</span>
        <span class="n">demand</span> <span class="o">=</span> <span class="n">class_</span><span class="o">.</span><span class="n">from_npz</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="n">net</span><span class="o">.</span><span class="n">shared</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;dem_&quot;</span><span class="p">)</span>
        <span class="n">net</span><span class="o">.</span><span class="n">set_demand</span><span class="p">(</span><span class="n">demand</span><span class="p">)</span>
        
        <span class="c1"># load cost</span>
        <span class="n">net</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">NetworkCost</span><span class="o">.</span><span class="n">from_npz</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="n">net</span><span class="o">.</span><span class="n">shared</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;cost_&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">net</span></div>
    
    <span class="n">from_npz</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_doc</span><span class="o">.</span><span class="n">from_npz</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cost associated with network.</span>
<span class="sd">        </span>
<span class="sd">        Can be either :class:`~paminco.net.cost.PolynomialCost`. or</span>
<span class="sd">        :class:`~paminco.net.cost.PiecewiseQuadraticCost`.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.cost</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span>

    <span class="nd">@cost</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cost</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">demand</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DemandFunction</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Demand associated with network.</span>
<span class="sd">        </span>
<span class="sd">        Can be either</span>
<span class="sd">        :class:`~paminco.net.demand.LinearDemandFunction`. or</span>
<span class="sd">        :class:`~paminco.net.demand.AffineDemandFunction`.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.demand</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_d&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Network has no demand, must be set with net.set_demand().&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

    <span class="nd">@demand</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">demand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_demand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shared</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shared</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Shared object for network objects.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.shared.Shared</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edges</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Network edges.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.shared.Edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">edges</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flow_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FlowDirection</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">graph_type</span>
    
    <span class="n">flow_direction</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Shared</span><span class="o">.</span><span class="n">flow_direction</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Whether the network&#39;s edges are directed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_single_commodity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Whether network demand consists of single commodity only.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_multi_commodity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Whether network demand consists of more than one commodity.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Nodes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Network nodes.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        paminco.net.shared.Nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">n</span>
    
    <span class="n">n</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Shared</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">m</span>
    
    <span class="n">m</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Shared</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the number of commodities in network.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demand</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get number of nodes, edges and commodities.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">dtype_int</span>
    
    <span class="n">dtype_int</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Shared</span><span class="o">.</span><span class="n">dtype_int</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype_float</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">dtype_float</span>
    
    <span class="n">dtype_float</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Shared</span><span class="o">.</span><span class="n">dtype_float</span><span class="o">.</span><span class="vm">__doc__</span></div>
</pre></div>

              </div>
              
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2021, Per Joachims, Max Klimm, Philipp Warode.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.2.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>